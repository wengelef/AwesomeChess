/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package chess

import org.kodein.di.Kodein
import org.kodein.di.generic.bind
import org.kodein.di.generic.instance
import org.kodein.di.generic.provider
import org.kodein.di.generic.singleton
import java.util.*
import kotlin.random.Random

object GameModule {
    fun get() = Kodein.Module("GameModule") {
        bind<ArrayList<Player>>() with provider { arrayListOf(Player(Black), Player(White)) }
        bind<Board>() with provider { Board() }
        bind<Game>() with singleton { Game(instance(), instance()) }
    }
}

val kodein = Kodein {
    import(GameModule.get())
}

val game: Game by kodein.instance()

fun main(args: Array<String>) {
    game.start()
}


data class Point(val x: Int, val y: Int) {
    override fun toString(): String = "[$x, $y]"
}

class Turn(val from: Point, val to: Point) {
    override fun toString(): String = "Turn ($from to $to)"
}

class Game(
        private val players: ArrayList<Player>,
        private val board: Board) {

    fun start() {
        println("Starting Game of Chess")


        var turnIndex = -1

        while (board.fields.toList().count { it.piece.isPresent && it.piece.get() == King } > 1) {


            ++turnIndex
            print("Turn $turnIndex ${state()}")

            val numberOfKings = board.fields.toList().count { it.piece.isPresent && it.piece.get() == King }

            println("Number of Kings on the Field $numberOfKings")

            val player = players[turnIndex.rem(2)]

            println("Current Player : ${player.team} has ${board.fields.toList().count { it.owner.isPresent && it.owner.get() == player.team }} Pieces")

            val turns = mutableListOf<Turn>()

            board.fields.forEachIndexed { x, y, field ->
                if (field.owner.isPresent && field.owner.get() == player.team) {
                    if (field.piece.isPresent) {
                        val piece = field.piece.get()

                        piece.moves.forEach { move ->
                            var newX = x
                            var newY = y

                            move.directions.forEach { (direction, number) ->
                                when (direction) {
                                    Direction.Forward -> {
                                        when (player.team) {
                                            is White -> newY += number
                                            is Black -> newY -= number
                                        }
                                    }
                                    Direction.Backward -> {
                                        when (player.team) {
                                            is White -> newY -= number
                                            is Black -> newY += number
                                        }
                                    }
                                    Direction.Left -> newX -= number
                                    Direction.Right -> newX += number
                                    //Direction.Diagonally -> TODO()
                                }
                            }

                            if (newX in 0..7 && newY in 0..7) {
                                val field = board.fields[newX, newY]
                                val owner = field.owner
                                if (!owner.isPresent ||
                                        owner.isPresent && owner.get() != player.team) {
                                    turns.add(Turn(Point(x, y), Point(newX, newY)))
                                }
                            }
                        }
                    }
                }
            }

            val turn = turns[Random.nextInt(turns.size)]

            turn.apply {
                board.fields[to.x, to.y] = board.fields[from.x, from.y]
                board.fields[from.x, from.y] = Field(Optional.empty(), Optional.empty())

                println("moved ${player.team} ${board.fields[to.x, to.y].piece.get()} from $from to $to")
            }
        }
    }


    fun state(): String {
        val fields = board.fields

        return fields.mapIndexed { x, y, field ->
            val owner: String = if (field.owner.isPresent) field.owner.get().toString() else "empty"
            val piece: String = if (field.piece.isPresent) field.piece.get().toString() else "none"

            if (x > 0 && x.rem(7) == 0) "[$x, $y] $owner $piece \n" else "[$x, $y] $owner $piece"
        }.toString()
    }
}


data class Player(val team: Team)

class Board(
        val fields: MutableMatrix<Field> = createMutableMatrix(8, 8) { x, y ->
            val team = when (y) {
                0, 1 -> Optional.of(White)
                6, 7 -> Optional.of(Black)
                else -> Optional.empty()
            }

            val piece = if (y == 0 || y == 7) {
                when (x) {
                    0, 7 -> Optional.of(Rook)
                    1, 6 -> Optional.of(Knight)
                    2, 5 -> Optional.of(Bishop)
                    3 -> if (team == Optional.of(White)) {
                        Optional.of(King)
                    } else {
                        Optional.of(Queen)
                    }
                    4 -> if (team == Optional.of(White)) {
                        Optional.of(Queen)
                    } else {
                        Optional.of(King)
                    }
                    else -> throw IllegalArgumentException("Field out of Bounds at $x, $y")
                }
            } else if (y == 1 || y == 6) {
                Optional.of(Pawn)
            } else {
                Optional.empty()
            }

            Field(team, piece)
        }
)

data class Field(val owner: Optional<out Team>, val piece: Optional<out Piece>)
